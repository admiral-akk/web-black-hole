(()=>{"use strict";var t="undefined"!=typeof Float32Array?Float32Array:Array;function s(){var s=new t(3);return t!=Float32Array&&(s[0]=0,s[1]=0,s[2]=0),s}function n(s){var n=new t(3);return n[0]=s[0],n[1]=s[1],n[2]=s[2],n}function a(t){var s=t[0],n=t[1],a=t[2];return Math.hypot(s,n,a)}function r(t,s,n){return t[0]=s[0]+n[0],t[1]=s[1]+n[1],t[2]=s[2]+n[2],t}function o(t,s,n){return t[0]=s[0]*n,t[1]=s[1]*n,t[2]=s[2]*n,t}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var t=0,s=arguments.length;s--;)t+=arguments[s]*arguments[s];return Math.sqrt(t)});var i,e=a;function h(t){return o(t,t,1/a(t)),function(t){if(Math.abs(1-a(t))>1e-6)throw console.log(`length: ${a(t)}`),new Error(`The vector: ${t} is not normalized`)}(t),t}function c(){return h([1,0,0])}s();class u{constructor(t=[0,0,0],s=c()){this.pos=t,this.dir=s}}class l{constructor(t=120,s=[0,0,0],n=c()){this.focalAngleRad=Math.PI*t/180,this.pos=s,this.dir=n}viewportToRay(t){const s=(t[0]-.5)*this.focalAngleRad/2,a=n(this.dir);var r,o,i,e,c,l;return r=a,i=[0,0,0],e=-s,l=[],(c=[])[0]=(o=a)[0]-i[0],c[1]=o[1]-i[1],c[2]=o[2]-i[2],l[0]=c[2]*Math.sin(e)+c[0]*Math.cos(e),l[1]=c[1],l[2]=c[2]*Math.cos(e)-c[0]*Math.sin(e),r[0]=l[0]+i[0],r[1]=l[1]+i[1],r[2]=l[2]+i[2],function(t,s,n,a){var r=[],o=[];r[0]=s[0]-n[0],r[1]=s[1]-n[1],r[2]=s[2]-n[2],o[0]=r[0]*Math.cos(a)-r[1]*Math.sin(a),o[1]=r[0]*Math.sin(a)+r[1]*Math.cos(a),o[2]=r[2],t[0]=o[0]+n[0],t[1]=o[1]+n[1],t[2]=o[2]+n[2]}(a,a,[0,0,0],-(t[1]-.5)*this.focalAngleRad/2),new u(n(this.pos),h(a))}}function f(t){return t<0?0:t>255?255:t}function d(s){const n=(a=[s[0],s[1],s[2],255],(r=new t(4))[0]=a[0],r[1]=a[1],r[2]=a[2],r[3]=a[3],r);var a,r;for(let t=0;t<3;t++)n[t]=f(n[t]);return function(t){if(t.filter((t=>t<0||t>255)).length>0)throw new Error(`The color: ${t} has out of bounds values!`)}(n),n}i=new t(4),t!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0,i[3]=0);class p{constructor(t=[0,0,0],n=1){this.pos=t,this.rad=n,this.temp=s()}distance(t){return s=t,n=this.pos,a=n[0]-s[0],r=n[1]-s[1],o=n[2]-s[2],Math.hypot(a,r,o)-this.rad;var s,n,a,r,o}normal(t){return this.temp=function(t,s,n){return t[0]=s[0]-n[0],t[1]=s[1]-n[1],t[2]=s[2]-n[2],t}(this.temp,t,this.pos),this.temp=o(this.temp,this.temp,1/e(this.temp)),n(this.temp)}color(t){let s=this.normal(t);return s=r(s,s,[1,1,1]),s=o(s,s,127.5),d(s)}}class m{constructor(t=.01,s=10){this.rayCollisionDistance=t,this.sdf=new p([1,0,0],.4),this.maxDistance=s}castRay(t){let s=[0,0,0],n=0;for(;n<this.maxDistance;){const a=this.sdf.distance(t.pos);if(a<this.rayCollisionDistance)return this.sdf.color(t.pos);s=o(s,t.dir,a),t.pos=r(t.pos,t.pos,s),n+=a}return d([0,0,0])}}const v=new class{constructor(){const t=document.getElementById("gpu-canvas");this.ctx=t.getContext("2d"),this.ctx.canvas.width=400,this.ctx.canvas.height=400,this.camera=new l,this.raycaster=new m}Render(){const t=this.ctx.getImageData(0,0,this.ctx.canvas.width,this.ctx.canvas.height),s=t.data;for(let t=0;t<s.length;t+=4){const n=Math.floor(Math.floor(t/4)%this.ctx.canvas.width),a=Math.floor(Math.floor(t/4)/this.ctx.canvas.width),r=[n/this.ctx.canvas.width,a/this.ctx.canvas.height],o=this.camera.viewportToRay(r);[s[t],s[t+1],s[t+2],s[t+3]]=this.raycaster.castRay(o)}this.ctx.putImageData(t,0,0)}};!function t(){const s=Date.now();v.Render(),console.log(`render time: ${Date.now()-s}ms`),setTimeout((()=>t()),100)}()})();