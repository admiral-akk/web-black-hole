(()=>{"use strict";var t="undefined"!=typeof Float32Array?Float32Array:Array;function s(){var s=new t(3);return t!=Float32Array&&(s[0]=0,s[1]=0,s[2]=0),s}function a(s){var a=new t(3);return a[0]=s[0],a[1]=s[1],a[2]=s[2],a}function n(t){var s=t[0],a=t[1],n=t[2];return Math.hypot(s,a,n)}function r(t,s,a){return t[0]=s[0]+a[0],t[1]=s[1]+a[1],t[2]=s[2]+a[2],t}function o(t,s,a){return t[0]=s[0]*a,t[1]=s[1]*a,t[2]=s[2]*a,t}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var t=0,s=arguments.length;s--;)t+=arguments[s]*arguments[s];return Math.sqrt(t)});var i,h=n;function e(t){return o(t,t,1/n(t)),function(t){if(Math.abs(1-n(t))>1e-6)throw console.log(`length: ${n(t)}`),new Error(`The vector: ${t} is not normalized`)}(t),t}function c(){return e([1,0,0])}s();class u{constructor(t=[0,0,0],s=c()){this.pos=t,this.dir=s}}class l{constructor(t=120,s=[0,0,0],a=c()){this.focalAngleRad=Math.PI*t/180,this.pos=s,this.dir=a}viewportToRay(t){const s=(t[0]-.5)*this.focalAngleRad/2,n=a(this.dir);var r,o,i,h,c,l;return r=n,i=[0,0,0],h=-s,l=[],(c=[])[0]=(o=n)[0]-i[0],c[1]=o[1]-i[1],c[2]=o[2]-i[2],l[0]=c[2]*Math.sin(h)+c[0]*Math.cos(h),l[1]=c[1],l[2]=c[2]*Math.cos(h)-c[0]*Math.sin(h),r[0]=l[0]+i[0],r[1]=l[1]+i[1],r[2]=l[2]+i[2],function(t,s,a,n){var r=[],o=[];r[0]=s[0]-a[0],r[1]=s[1]-a[1],r[2]=s[2]-a[2],o[0]=r[0]*Math.cos(n)-r[1]*Math.sin(n),o[1]=r[0]*Math.sin(n)+r[1]*Math.cos(n),o[2]=r[2],t[0]=o[0]+a[0],t[1]=o[1]+a[1],t[2]=o[2]+a[2]}(n,n,[0,0,0],-(t[1]-.5)*this.focalAngleRad/2),new u(a(this.pos),e(n))}}function f(t){return t<0?0:t>255?255:t}function d(s){const a=(n=[s[0],s[1],s[2],255],(r=new t(4))[0]=n[0],r[1]=n[1],r[2]=n[2],r[3]=n[3],r);var n,r;for(let t=0;t<3;t++)a[t]=f(a[t]);return function(t){if(t.filter((t=>t<0||t>255)).length>0)throw new Error(`The color: ${t} has out of bounds values!`)}(a),a}i=new t(4),t!=Float32Array&&(i[0]=0,i[1]=0,i[2]=0,i[3]=0);class p{constructor(t=[0,0,0],a=1){this.pos=t,this.rad=a,this.temp=s()}distance(t){return s=t,a=this.pos,n=a[0]-s[0],r=a[1]-s[1],o=a[2]-s[2],Math.hypot(n,r,o)-this.rad;var s,a,n,r,o}normal(t){return this.temp=function(t,s,a){return t[0]=s[0]-a[0],t[1]=s[1]-a[1],t[2]=s[2]-a[2],t}(this.temp,t,this.pos),this.temp=o(this.temp,this.temp,1/h(this.temp)),a(this.temp)}color(t){let s=this.normal(t);return s=r(s,s,[1,1,1]),s=o(s,s,127.5),d(s)}}class v{constructor(t=.01,s=10){this.rayCollisionDistance=t,this.sdf=new p([1,0,0],.4),this.maxDistance=s}castRay(t){let s=[0,0,0],a=0;for(;a<this.maxDistance;){const n=this.sdf.distance(t.pos);if(n<this.rayCollisionDistance)return this.sdf.color(t.pos);s=o(s,t.dir,n),t.pos=r(t.pos,t.pos,s),a+=n}return d([0,0,0])}}(new class{constructor(){const t=document.getElementById("gpu-canvas");this.ctx=t.getContext("2d"),this.ctx.canvas.width=400,this.ctx.canvas.height=400,this.camera=new l,this.raycaster=new v}Render(){const t=this.ctx.getImageData(0,0,this.ctx.canvas.width,this.ctx.canvas.height),s=t.data;for(let t=0;t<s.length;t+=4){const a=Math.floor(Math.floor(t/4)%this.ctx.canvas.width),n=Math.floor(Math.floor(t/4)/this.ctx.canvas.width),r=[a/this.ctx.canvas.width,n/this.ctx.canvas.height],o=this.camera.viewportToRay(r);[s[t],s[t+1],s[t+2],s[t+3]]=this.raycaster.castRay(o)}this.ctx.putImageData(t,0,0)}}).Render()})();